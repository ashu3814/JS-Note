
# 🔥 Advanced JavaScript Arrays - Master Guide

## 📚 Table of Contents
1. [Array Combining Operations](#array-combining-operations)
2. [Spread Operator Mastery](#spread-operator-mastery)
3. [Destructuring Arrays](#destructuring-arrays)
4. [Advanced Iteration Patterns](#advanced-iteration-patterns)
5. [Array Performance & Memory](#array-performance--memory)
6. [Functional Programming with Arrays](#functional-programming-with-arrays)
7. [Array-like Objects](#array-like-objects)
8. [Advanced Search & Sort](#advanced-search--sort)
9. [Nested Arrays & Multidimensional](#nested-arrays--multidimensional)
10. [Modern Array Methods](#modern-array-methods)
11. [Array Optimization Techniques](#array-optimization-techniques)
12. [Real-world Patterns](#real-world-patterns)

---

## 🔗 Array Combining Operations

### 1. concat() - Traditional Concatenation
**Definition:** Merges two or more arrays without modifying existing arrays.  
**Syntax:** `arr1.concat(arr2, arr3, ..., value1, value2)`  
**Returns:** New combined array.  
**Mutates:** ❌ No  

**Examples:**
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [7, 8, 9];

// Basic concat
const combined = arr1.concat(arr2);
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Multiple arrays
const multiCombined = arr1.concat(arr2, arr3);
console.log(multiCombined); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// With individual values
const withValues = arr1.concat(arr2, 'a', 'b');
console.log(withValues); // [1, 2, 3, 4, 5, 6, 'a', 'b']

// Nested arrays (shallow concat)
const nested1 = [[1, 2], [3, 4]];
const nested2 = [[5, 6]];
const nestedResult = nested1.concat(nested2);
console.log(nestedResult); // [[1, 2], [3, 4], [5, 6]]
```

### 2. Array Union Operations
**Definition:** Combining arrays while handling duplicates.  

```javascript
// Union with duplicates
const union = (arr1, arr2) => arr1.concat(arr2);

// Union without duplicates (using Set)
const uniqueUnion = (arr1, arr2) => [...new Set([...arr1, ...arr2])];

// Union without duplicates (using filter)
const uniqueUnion2 = (arr1, arr2) => {
  return arr1.concat(arr2.filter(item => !arr1.includes(item)));
};

// Example usage
const a = [1, 2, 3, 2];
const b = [3, 4, 5, 4];
console.log(union(a, b));        // [1, 2, 3, 2, 3, 4, 5, 4]
console.log(uniqueUnion(a, b));  // [1, 2, 3, 4, 5]
console.log(uniqueUnion2(a,b)); // [ 1, 2, 3, 2, 4, 5 ] (Note: keeps duplicates from arr1)
                                // For a truly unique union like the Set version with filter:
const uniqueUnionFilterStrict = (arr1, arr2) => {
    const combined = arr1.concat(arr2);
    return combined.filter((item, index) => combined.indexOf(item) === index);
};
console.log(uniqueUnionFilterStrict(a, b)); // [1, 2, 3, 4, 5]
```

### 3. Array Intersection
**Definition:** Finding common elements between arrays.  

```javascript
// Simple intersection (may contain duplicates if present in arr1 and arr2)
const intersection = (arr1, arr2) => {
  return arr1.filter(item => arr2.includes(item));
};

// Unique intersection
const uniqueIntersection = (arr1, arr2) => {
  const set2 = new Set(arr2);
  return [...new Set(arr1.filter(item => set2.has(item)))];
};

// Multiple arrays intersection
const multiIntersection = (...arrays) => {
  if (arrays.length === 0) return [];
  return arrays.reduce((acc, curr) => 
    acc.filter(item => curr.includes(item))
  );
};

// Examples
const x = [1, 2, 3, 4, 3];
const y = [3, 4, 5, 6, 3];
const z = [4, 5, 6, 7, 3];

console.log(intersection(x, y));           // [3, 4, 3]
console.log(uniqueIntersection(x, y));     // [3, 4]
console.log(multiIntersection(x, y, z));   // [4, 3] (order and duplicates from first array)

// For unique multi-intersection:
const uniqueMultiIntersection = (...arrays) => {
  if (arrays.length === 0) return [];
  let result = [...new Set(arrays[0])]; // Start with unique elements of the first array
  for (let i = 1; i < arrays.length; i++) {
    const currentSet = new Set(arrays[i]);
    result = result.filter(item => currentSet.has(item));
  }
  return result;
};
console.log(uniqueMultiIntersection(x, y, z)); // [3, 4] (order depends on first array's unique items)
```

### 4. Array Difference
**Definition:** Finding elements that exist in one array but not another.  

```javascript
// Difference (A - B): elements in arr1 that are not in arr2
const difference = (arr1, arr2) => {
  const set2 = new Set(arr2);
  return arr1.filter(item => !set2.has(item));
};

// Symmetric difference (A ∪ B) - (A ∩ B)
// Elements that are in A or B but not in both
const symmetricDifference = (arr1, arr2) => {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  
  const diff1 = arr1.filter(item => !set2.has(item));
  const diff2 = arr2.filter(item => !set1.has(item));
  
  return [...diff1, ...diff2];
};

// Examples
const p = [1, 2, 3, 4, 5, 3];
const q = [4, 5, 6, 7, 8, 5];

console.log(difference(p, q));           // [1, 2, 3, 3] (elements from p not in q)
console.log(difference(q, p));           // [6, 7, 8] (elements from q not in p)

// For unique difference:
const uniqueDifference = (arr1, arr2) => {
  const set2 = new Set(arr2);
  return [...new Set(arr1.filter(item => !set2.has(item)))];
}
console.log(uniqueDifference(p,q)); // [1, 2, 3]

console.log(symmetricDifference(p, q)); // [1, 2, 3, 3, 6, 7, 8]

// For unique symmetric difference:
const uniqueSymmetricDifference = (arr1, arr2) => {
    return [...new Set(symmetricDifference(arr1, arr2))];
}
console.log(uniqueSymmetricDifference(p, q)); // [1, 2, 3, 6, 7, 8]
```

---

## ⚡ Spread Operator Mastery

### 1. Basic Spread Syntax
**Definition:** Expands an iterable (like an array or string) into individual elements.  
**Syntax:** `...iterable`  

```javascript
const arr = [1, 2, 3];

// Spreading in function calls
console.log(Math.max(...arr)); // 3 (equivalent to Math.max(1, 2, 3))

// Spreading in array literals
const newArr = [0, ...arr, 4]; 
console.log(newArr); // [0, 1, 2, 3, 4]

// Spreading strings
const chars = [...'hello']; 
console.log(chars); // ['h', 'e', 'l', 'l', 'o']
```

### 2. Array Cloning with Spread
**Definition:** Creating shallow copies of arrays.  

```javascript
const original = [1, 2, 3, [4, 5]];

// Shallow clone
const clone = [...original];
console.log(clone); // [1, 2, 3, [4, 5]]

// Modifying clone doesn't affect original (for primitive values)
clone[0] = 'changed';
console.log("Clone after primitive change:", clone);       // ['changed', 2, 3, [4, 5]]
console.log("Original after primitive change in clone:", original); // [1, 2, 3, [4, 5]] (unchanged)

// But nested objects/arrays are still referenced (shallow copy)
clone[3][0] = 'nested changed';
console.log("Clone after nested change:", clone);       // ['changed', 2, 3, ['nested changed', 5]]
console.log("Original after nested change in clone:", original); // [1, 2, 3, ['nested changed', 5]] (changed!)
```

### 3. Advanced Spread Combinations
**Definition:** Complex operations using spread operator.  

```javascript
// Merging multiple arrays
const arrA = [1, 2];
const arrB = [3, 4];
const arrC = [5, 6];
const merged = [...arrA, ...arrB, ...arrC]; 
console.log(merged); // [1, 2, 3, 4, 5, 6]

// Inserting elements at specific positions
const insert = (arr, index, ...items) => [
  ...arr.slice(0, index),
  ...items,
  ...arr.slice(index)
];

const numbersList = [1, 2, 5, 6];
const resultInsert = insert(numbersList, 2, 3, 4);
console.log(resultInsert); // [1, 2, 3, 4, 5, 6]

// Converting Set to Array
const set = new Set([1, 2, 3, 2, 1]);
const uniqueArrayFromSet = [...set]; 
console.log(uniqueArrayFromSet); // [1, 2, 3]

// Converting NodeList to Array (run in browser console)
// const elements = [...document.querySelectorAll('div')];
// console.log(Array.isArray(elements)); // true

// Spread vs concat performance comparison
// Generally, for a small number of arrays, spread is often more concise and can be fast.
// For a very large number of arrays or extremely large individual arrays being concatenated,
// `concat` might be more performant or avoid "Maximum call stack size exceeded" errors.
const large1 = new Array(10000).fill(1);
const large2 = new Array(10000).fill(2);

// Method 1: Spread (can cause stack overflow with many arrays or very large arrays in some engines)
// const spreadResult = [...large1, ...large2, ...large1, ...large2, ...]; // if too many spreads
let spreadResult;
try {
    spreadResult = [...large1, ...large2]; // This is usually fine
    console.log("Spread result length:", spreadResult.length);
} catch (e) {
    console.error("Spread operator failed for large arrays:", e.message);
}


// Method 2: Concat (safer for many/large arrays)
const concatResult = large1.concat(large2);
console.log("Concat result length:", concatResult.length);
```

### 4. Spread with Destructuring
**Definition:** Combining spread with destructuring assignment, primarily using the rest syntax (`...rest`).  

```javascript
const numbers = [1, 2, 3, 4, 5];

// Rest elements (collecting remaining elements into an array)
const [firstNum, secondNum, ...restElements] = numbers;
console.log(firstNum);      // 1
console.log(secondNum);     // 2
console.log(restElements);  // [3, 4, 5]

// Swapping variables (though destructuring itself is the key here, not spread)
let valA = 1, valB = 2;
[valA, valB] = [valB, valA];
console.log("Swapped valA:", valA, "valB:", valB); // valA: 2, valB: 1

// Function parameters (rest parameters to gather arguments into an array)
const sumAll = (...nums) => nums.reduce((acc, num) => acc + num, 0);
console.log(sumAll(1, 2, 3, 4)); // 10
```

---

## 🎯 Destructuring Arrays

### 1. Basic Destructuring
**Definition:** Extracting values from arrays into distinct variables.  
**Syntax:** `const [var1, var2, ...rest] = array`  

```javascript
const colors = ['red', 'green', 'blue', 'yellow'];

// Basic destructuring
const [primary, secondary] = colors;
console.log(primary);   // 'red'
console.log(secondary); // 'green'

// Skipping elements using a comma
const [firstColor, , thirdColor] = colors;
console.log(firstColor); // 'red'
console.log(thirdColor); // 'blue'

// Default values for variables if array elements are undefined
const [a, b, c, d, e = 'defaultColor'] = colors;
console.log(e); // 'defaultColor' (since colors[4] is undefined)

const shortColors = ['purple'];
const [col1, col2 = 'indigo'] = shortColors;
console.log(col1); // 'purple'
console.log(col2); // 'indigo'
```

### 2. Advanced Destructuring Patterns
**Definition:** Complex destructuring scenarios, including nested arrays and rest syntax.  

```javascript
// Nested array destructuring
const nested = [[1, 2], [3, 4], [5, 6]];
const [[val_a, val_b], [val_c, val_d]] = nested;
console.log(val_a, val_b, val_c, val_d); // 1, 2, 3, 4

// Mixed destructuring (arrays and objects could be mixed if the structure allows)
const mixedData = [1, [2, 3], { name: 'Alice' }, 4];
const [num_x, [num_y, num_z], userObj, num_w] = mixedData;
console.log(num_x, num_y, num_z, userObj, num_w); // 1, 2, 3, { name: 'Alice' }, 4

// Rest in destructuring (already shown in Spread Operator section, reiterated here)
const numberSeries = [1, 2, 3, 4, 5];
const [head, ...tail] = numberSeries;
console.log(head); // 1
console.log(tail); // [2, 3, 4, 5]

// Function return destructuring
const getCoordinates = () => [10, 20, 30];
const [xCoord, yCoord, zCoord] = getCoordinates();
console.log(xCoord, yCoord, zCoord); // 10, 20, 30
```

### 3. Destructuring in Function Parameters
**Definition:** Using destructuring directly in function signatures to unpack array arguments.  

```javascript
// Array parameter destructuring
const processPoint = ([x, y, z = 0]) => { // z has a default value
  return { x: x * 2, y: y * 2, z: z * 2 };
};

const point2D = [5, 10];
console.log(processPoint(point2D)); // { x: 10, y: 20, z: 0 }

const point3D = [3, 6, 9];
console.log(processPoint(point3D)); // { x: 6, y: 12, z: 18 }

// With default values for the array parameter itself
const createUser = ([name = 'Anonymous', age = 0] = []) => {
  // The `= []` ensures that if no argument or `undefined` is passed,
  // it defaults to an empty array, which then allows `name` and `age` defaults to apply.
  return { name, age };
};

console.log(createUser(['John', 25])); // { name: 'John', age: 25 }
console.log(createUser(['Jane']));     // { name: 'Jane', age: 0 }
console.log(createUser([]));           // { name: 'Anonymous', age: 0 }
console.log(createUser());             // { name: 'Anonymous', age: 0 }
```

---

## 🔄 Advanced Iteration Patterns

### 1. Multiple Array Iteration
**Definition:** Iterating over multiple arrays simultaneously.  

```javascript
const names = ['Alice', 'Bob', 'Charlie'];
const ages = [25, 30, 35, 40]; // Note: ages is longer
const cities = ['NYC', 'LA'];  // Note: cities is shorter

// Using map with index (relies on the length of the array `map` is called on)
const combinedInfo = names.map((name, index) => ({
  name,
  age: ages[index],     // Will be undefined if ages is shorter
  city: cities[index]   // Will be undefined if cities is shorter
}));
console.log("Combined Info (names.map):", combinedInfo);
// [
//   { name: 'Alice', age: 25, city: 'NYC' },
//   { name: 'Bob', age: 30, city: 'LA' },
//   { name: 'Charlie', age: 35, city: undefined }
// ]

// Custom zip function (stops at the shortest array's length)
const zip = (...arrays) => {
  if (arrays.length === 0) return [];
  const shortestLength = Math.min(...arrays.map(arr => arr.length));
  return Array.from({ length: shortestLength }, (_, i) => arrays.map(arr => arr[i]));
};

const zippedData = zip(names, ages, cities);
console.log("Zipped Data:", zippedData);
// [['Alice', 25, 'NYC'], ['Bob', 30, 'LA']]

// Custom zipLongest function (fills with a placeholder for shorter arrays)
const zipLongest = (fillValue = undefined, ...arrays) => {
    if (arrays.length === 0) return [];
    const longestLength = Math.max(...arrays.map(arr => arr.length));
    return Array.from({ length: longestLength }, (_, i) => 
        arrays.map(arr => (i < arr.length ? arr[i] : fillValue))
    );
};
const zippedLongestData = zipLongest(null, names, ages, cities);
console.log("Zipped Longest Data (fill with null):", zippedLongestData);
// [
//   [ 'Alice', 25, 'NYC' ],
//   [ 'Bob', 30, 'LA' ],
//   [ 'Charlie', 35, null ],
//   [ null, 40, null ]
// ]
```

### 2. Array Chunking
**Definition:** Splitting an array into smaller, equal-sized (except possibly the last) chunks.  

```javascript
// Chunk function using a for loop and slice
const chunk = (array, size) => {
  if (size <= 0) throw new Error("Chunk size must be positive.");
  const chunks = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
};

// Chunk function using reduce
const chunkReduce = (array, size) => {
  if (size <= 0) throw new Error("Chunk size must be positive.");
  return array.reduce((chunks, item, index) => {
    const chunkIndex = Math.floor(index / size);
    if (!chunks[chunkIndex]) {
      chunks[chunkIndex] = []; // Start a new chunk
    }
    chunks[chunkIndex].push(item);
    return chunks;
  }, []);
};

const numbersToChunk = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log("Chunk (size 3):", chunk(numbersToChunk, 3)); 
// [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
console.log("ChunkReduce (size 4):", chunkReduce(numbersToChunk, 4)); 
// [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]
```

### 3. Array Partitioning
**Definition:** Splitting an array into two or more sub-arrays based on one or more predicate functions.  

```javascript
// Partition function (into two groups: truthy and falsy based on predicate)
const partition = (array, predicate) => {
  return array.reduce(
    (acc, item, index, arr) => { // `acc` is [truthyArray, falsyArray]
      (predicate(item, index, arr) ? acc[0] : acc[1]).push(item);
      return acc;
    },
    [[], []] // Initial value: [truthyArray, falsyArray]
  );
};

const numbersToPartition = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const [evens, odds] = partition(numbersToPartition, n => n % 2 === 0);
console.log("Evens:", evens); // [2, 4, 6, 8]
console.log("Odds:", odds);  // [1, 3, 5, 7, 9]

// Multiple partitions (partitionBy): groups items based on the first predicate they satisfy
const partitionBy = (array, ...predicates) => {
  // Create n+1 groups, where n is the number of predicates.
  // The last group is for items that don't satisfy any predicate.
  const groups = Array.from({ length: predicates.length + 1 }, () => []);
  
  array.forEach(item => {
    let predicateIndex = -1;
    for (let i = 0; i < predicates.length; i++) {
        if (predicates[i](item)) {
            predicateIndex = i;
            break;
        }
    }
    
    if (predicateIndex !== -1) {
        groups[predicateIndex].push(item);
    } else {
        groups[predicates.length].push(item); // Add to the "catch-all" group
    }
  });
  
  return groups;
};

const dataToPartition = [1, 5, 10, 15, 22, 25, 30, 100];
const [small, medium, large, others] = partitionBy(
  dataToPartition,
  n => n < 10,      // Group 0: small
  n => n < 20,      // Group 1: medium (10 <= n < 20)
  n => n < 30       // Group 2: large (20 <= n < 30)
                     // Group 3: others (n >= 30)
);
console.log("Small numbers:", small);  // [1, 5]
console.log("Medium numbers:", medium); // [10, 15]
console.log("Large numbers:", large);  // [22, 25]
console.log("Other numbers:", others); // [30, 100]
```

---

## ⚡ Array Performance & Memory

*(Note: `performance.now()` is available in browsers and Node.js via `require('perf_hooks').performance`. The examples below are illustrative and actual timings will vary.)*

### 1. Performance Comparison
**Definition:** Understanding the performance characteristics of different operations.  

```javascript
// Performance testing utility (simplified)
const timeIt = (label, fn, iterations = 100000) => {
  // In Node.js, use: const { performance } = require('perf_hooks');
  // In Browsers, performance is global.
  // For this Markdown, we'll assume performance is available.
  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    fn();
  }
  const end = performance.now();
  console.log(`${label}: ${(end - start).toFixed(3)} ms for ${iterations} iterations`);
  return end - start;
};

// Array creation methods
console.log("--- Array Creation ---");
timeIt('Array Literal', () => [1, 2, 3, 4, 5]);
timeIt('Array Constructor', () => new Array(1, 2, 3, 4, 5));
timeIt('Array.from literal', () => Array.from([1, 2, 3, 4, 5]));

// Array copying methods
const largeArrayToCopy = new Array(1000).fill(0).map((_, i) => i);
console.log("--- Array Copying (1000 elements) ---");
timeIt('Spread copy', () => [...largeArrayToCopy], 10000);
timeIt('Slice copy', () => largeArrayToCopy.slice(), 10000);
timeIt('Array.from copy', () => Array.from(largeArrayToCopy), 10000);
timeIt('concat copy', () => [].concat(largeArrayToCopy), 10000);


// Search methods
const searchArray = new Array(10000).fill(0).map((_, i) => i);
const target = 5000;
const targetNotFound = -1;

console.log("--- Array Search (10000 elements, target in middle) ---");
timeIt('indexOf (found)', () => searchArray.indexOf(target), 1000);
timeIt('includes (found)', () => searchArray.includes(target), 1000);
timeIt('find (found)', () => searchArray.find(x => x === target), 1000);

console.log("--- Array Search (10000 elements, target not found) ---");
timeIt('indexOf (not found)', () => searchArray.indexOf(targetNotFound), 1000);
timeIt('includes (not found)', () => searchArray.includes(targetNotFound), 1000);
timeIt('find (not found)', () => searchArray.find(x => x === targetNotFound), 1000);

// General observations (can vary by JS engine):
// - Literal creation is usually fastest.
// - `slice()` or spread are often fast for copying. `Array.from` can be slower.
// - `includes()` can be faster than `indexOf() !== -1` for simple presence checks.
// - `find()` has overhead of a callback function.
```

### 2. Memory-Efficient Operations
**Definition:** Techniques to minimize memory usage, especially by avoiding unnecessary intermediate arrays.  

```javascript
const numbersForMemory = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

// ❌ Creates multiple intermediate arrays:
// 1. filter -> new array
// 2. map -> new array
// 3. filter -> new array
const inefficientChain = numbersForMemory
  .filter(n => n % 2 === 0)  // [2, 4, 6, 8, 10, 12, 14]
  .map(n => n * 3)           // [6, 12, 18, 24, 30, 36, 42]
  .filter(n => n > 20);      // [24, 30, 36, 42]
console.log("Inefficient Chain Result:", inefficientChain);

// ✅ Single pass with reduce, creates only the final array
const efficientReduce = numbersForMemory.reduce((acc, n) => {
  if (n % 2 === 0) { // First filter condition
    const tripled = n * 3; // Map operation
    if (tripled > 20) { // Second filter condition
      acc.push(tripled);
    }
  }
  return acc;
}, []);
console.log("Efficient Reduce Result:", efficientReduce);

// ✅ Single pass with a for loop (often most performant and memory-efficient for complex logic)
const efficientLoop = [];
for (const n of numbersForMemory) {
    if (n % 2 === 0) {
        const tripled = n * 3;
        if (tripled > 20) {
            efficientLoop.push(tripled);
        }
    }
}
console.log("Efficient Loop Result:", efficientLoop);


// Lazy evaluation with generators (processes items one by one, on demand)
function* lazyFilter(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) {
      yield item; // Yields only when an item matches
    }
  }
}

function* lazyMap(iterable, transform) {
  for (const item of iterable) {
    yield transform(item); // Yields transformed item
  }
}

// Usage of lazy operations
const lazyResultGenerator = lazyMap(
  lazyFilter(
    lazyFilter(numbersForMemory, n => n % 2 === 0), // First filter
    n => n * 3 > 20 // Combined map and second filter logic (simplified for example)
                  // More accurately: lazyMap(lazyFilter(numbers, n=>n%2===0), n=>n*3)
                  // then lazyFilter(that_result, n=> n > 20)
  ),
  n => `Item: ${n}` // Final map
);

// Only computes when iterated (e.g., by spreading or for...of)
// Example: Let's do the full chain with generators
function* lazyPipeline(sourceArray) {
    let step1 = lazyFilter(sourceArray, n => n % 2 === 0);
    let step2 = lazyMap(step1, n => n * 3);
    let step3 = lazyFilter(step2, n => n > 20);
    yield* step3; // yield* delegates to another generator
}

const finalLazyResult = [...lazyPipeline(numbersForMemory)];
console.log("Lazy Generator Pipeline Result:", finalLazyResult); // [24, 30, 36, 42]
// The benefit is memory: if you only need the first few items, not all are computed.
```

### 3. Large Array Handling
**Definition:** Techniques for working with very large arrays that might not fit comfortably in memory or might block the main thread.  

```javascript
// Batch processing (to avoid blocking main thread for long operations)
const processBatchAsync = async (array, batchSize = 1000, processorFn) => {
  const results = [];
  for (let i = 0; i < array.length; i += batchSize) {
    const batch = array.slice(i, i + batchSize);
    // Simulate async processing for the batch
    const batchResults = await processorFn(batch); 
    results.push(...batchResults);
    
    // Yield control to the event loop briefly
    await new Promise(resolve => setTimeout(resolve, 0)); 
  }
  return results;
};

// Example usage (conceptual, run in an async context)
const veryLargeArray = new Array(50000).fill(0).map((_, i) => i);
const heavyAsyncProcessor = async (batch) => {
  // Simulate some heavy async work per item
  return Promise.all(batch.map(item => 
    new Promise(resolve => setTimeout(() => resolve(item * 2), 1))
  ));
};

/*
async function runBatchProcessing() {
    console.log("Starting batch processing...");
    const startTime = performance.now();
    const processedData = await processBatchAsync(veryLargeArray, 5000, heavyAsyncProcessor);
    const endTime = performance.now();
    console.log(`Batch processing finished in ${(endTime - startTime).toFixed(2)} ms. Results: ${processedData.length}`);
    // console.log(processedData.slice(0,5));
}
// runBatchProcessing(); // Uncomment to run
*/

// Virtual scrolling array (for UI or data that's generated on demand)
class VirtualArray {
  constructor(length, itemGeneratorFn) {
    if (typeof length !== 'number' || length < 0) {
      throw new Error("Length must be a non-negative number.");
    }
    if (typeof itemGeneratorFn !== 'function') {
      throw new Error("Item generator must be a function.");
    }
    this.length = length;
    this.generator = itemGeneratorFn;
    this.cache = new Map(); // Optional: cache generated items
  }
  
  get(index) {
    if (index < 0 || index >= this.length) {
      return undefined; // Or throw error
    }
    if (!this.cache.has(index)) {
      // console.log(`Generating item for index ${index}`); // For demo
      this.cache.set(index, this.generator(index));
    }
    return this.cache.get(index);
  }
  
  slice(start, end) {
    const actualEnd = Math.min(end, this.length);
    const actualStart = Math.max(0, start);
    const result = [];
    for (let i = actualStart; i < actualEnd; i++) {
      result.push(this.get(i)); // Uses the .get() method, so benefits from caching
    }
    return result;
  }
}

const virtualNumbers = new VirtualArray(1000000, i => `GeneratedItem-${i * i}`);
console.log("VirtualArray slice (100-105):", virtualNumbers.slice(100, 105)); 
// [ 'GeneratedItem-10000', 'GeneratedItem-10201', 'GeneratedItem-10404', 
//   'GeneratedItem-10609', 'GeneratedItem-10816' ]
console.log("VirtualArray get item 100 again (from cache):", virtualNumbers.get(100));
// 'GeneratedItem-10000'
```

---

## 🎨 Functional Programming with Arrays

### 1. Composition and Piping
**Definition:** Combining multiple functions to create a new function or to process data through a series of steps.  
*   **Compose:** Functions are applied from right to left. `compose(f, g, h)(x)` is `f(g(h(x)))`.
*   **Pipe:** Functions are applied from left to right. `pipe(f, g, h)(x)` is `h(g(f(x)))`. (Note: my example below uses `pipe(h, g, f)(x)` for `f(g(h(x)))` which is more common for data flow). Let's stick to the common definition of pipe as left-to-right data flow.

```javascript
// Compose function (right-to-left execution of functions)
const compose = (...fns) => (initialValue) => fns.reduceRight((acc, fn) => fn(acc), initialValue);

// Pipe function (left-to-right execution of functions)
const pipe = (...fns) => (initialValue) => fns.reduce((acc, fn) => fn(acc), initialValue);

// Helper functions for demonstration
const double = x => x * 2;
const addOne = x => x + 1;
const square = x => x * x;
const toStringVal = x => `Value: ${x}`;

// Usage with single values
const composedFn = compose(square, addOne, double); // double -> addOne -> square
// square(addOne(double(3))) = square(addOne(6)) = square(7) = 49
console.log("Composed (3):", composedFn(3)); // 49

const pipedFn = pipe(double, addOne, square); // double -> addOne -> square
// square(addOne(double(3)))
console.log("Piped (3):", pipedFn(3));    // 49

// Array processing with pipe (more natural for data flow)
const numbersForPipe = [-1, 0, 2, -3, 4, 5];

const processNumbersWithPipe = pipe(
  arr => arr.filter(n => n > 0),          // [2, 4, 5]
  arr => arr.map(n => n * 2),             // [4, 8, 10]
  arr => arr.reduce((sum, n) => sum + n, 0) // 22
);
console.log("processNumbersWithPipe:", processNumbersWithPipe(numbersForPipe)); // 22

const processNumbersWithCompose = compose(
  arr => arr.reduce((sum, n) => sum + n, 0), // Step 3
  arr => arr.map(n => n * 2),             // Step 2
  arr => arr.filter(n => n > 0)           // Step 1
);
console.log("processNumbersWithCompose:", processNumbersWithCompose(numbersForPipe)); // 22
```

### 2. Currying with Arrays
**Definition:** Transforming a function that takes multiple arguments into a sequence of functions that each take a single argument. For array methods, this often means creating functions that take the callback/config first, and return a new function that takes the array.  

```javascript
// Curried filter: takes predicate, returns function that takes array
const filter = predicate => array => array.filter(predicate);

// Curried map: takes transform, returns function that takes array
const map = transformFn => array => array.map(transformFn);

// Curried reduce: takes reducer and initialVal, returns function that takes array
const reduce = (reducerFn, initialValue) => array => array.reduce(reducerFn, initialValue);

// Creating specialized functions using currying
const filterEven = filter(n => n % 2 === 0);
const doubleAll = map(n => n * 2);
const sumAllElements = reduce((acc, n) => acc + n, 0);

// Usage with pipe
const numbersForCurrying = [1, 2, 3, 4, 5, 6];

const curriedProcessingPipeline = pipe(
  filterEven,       // Applies filterEven to the array
  doubleAll,        // Applies doubleAll to the result
  sumAllElements    // Applies sumAllElements to that result
);
// filterEven([1,2,3,4,5,6]) -> [2,4,6]
// doubleAll([2,4,6]) -> [4,8,12]
// sumAllElements([4,8,12]) -> 24
console.log("Curried Pipeline Result:", curriedProcessingPipeline(numbersForCurrying)); // 24

// Direct usage of specialized functions
const evenNumbers = filterEven(numbersForCurrying); // [2, 4, 6]
const doubledEvens = doubleAll(evenNumbers);        // [4, 8, 12]
const sumOfDoubledEvens = sumAllElements(doubledEvens); // 24
console.log("Sum of Doubled Evens (manual steps):", sumOfDoubledEvens);
```

### 3. Monadic Operations (Conceptual with Maybe)
**Definition:** Monads are a concept from functional programming (specifically category theory) that provide a way to structure computations in terms of sequences of operations, often handling side effects or context (like absence of a value). `Maybe` is a common example for handling potentially null/undefined values gracefully.  

```javascript
// A simplified Maybe monad for safe array operations
class Maybe {
  constructor(value) {
    this._value = value; // Use _value to avoid conflict with a potential 'value' property if value is an object
  }
  
  static of(value) {
    return new Maybe(value);
  }
  
  isNothing() {
    return this._value === null || this._value === undefined;
  }
  
  // map applies a function if there's a value, otherwise stays Nothing
  map(fn) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value));
  }
  
  // flatMap (or chain/bind) applies a function that returns a Maybe,
  // and flattens the result (avoids Maybe<Maybe<T>>)
  flatMap(fnReturningMaybe) {
    return this.isNothing() ? Maybe.of(null) : fnReturningMaybe(this._value);
  }
  
  getOrElse(defaultValue) {
    return this.isNothing() ? defaultValue : this._value;
  }

  get() { // For convenience, though typically you'd use getOrElse or pattern match
    return this._value;
  }
}

// Safe array operations using Maybe
const safeGet = (array, index) => {
  if (!Array.isArray(array) || index < 0 || index >= array.length) {
    return Maybe.of(null); // Or Maybe.of(undefined)
  }
  return Maybe.of(array[index]);
};

const safeHead = (array) => safeGet(array, 0);

// Usage
const numbersArray = [10, 20, 30];
const emptyArray = [];

// Example 1: Get head, double it, add 5, or default to 0
const headResult = safeHead(numbersArray)       // Maybe<10>
  .map(x => x * 2)                            // Maybe<20>
  .map(x => x + 5)                            // Maybe<25>
  .getOrElse(0);                              // 25
console.log("Head result (numbersArray):", headResult); // 25

const emptyHeadResult = safeHead(emptyArray)   // Maybe<null>
  .map(x => x * 2)                            // Stays Maybe<null>
  .map(x => x + 5)                            // Stays Maybe<null>
  .getOrElse(0);                              // 0 (default value)
console.log("Head result (emptyArray):", emptyHeadResult); // 0

// Example with flatMap: find user, then get their address (address itself might be Maybe)
const usersDB = {
  'user1': { name: 'Alice', addressId: 'addr1' },
  'user2': { name: 'Bob' } // No addressId
};
const addressesDB = {
  'addr1': { street: '123 Main St', city: 'Anytown' }
};

const findUser = userId => Maybe.of(usersDB[userId]);
const getAddress = user => Maybe.of(user.addressId).flatMap(addrId => Maybe.of(addressesDB[addrId]));

const alicesCity = findUser('user1')          // Maybe<{name:'Alice', addressId:'addr1'}>
  .flatMap(getAddress)                      // Maybe<{street:..., city:...}>
  .map(address => address.city)             // Maybe<'Anytown'>
  .getOrElse('City not found');
console.log("Alice's City:", alicesCity); // Anytown

const bobsCity = findUser('user2')            // Maybe<{name:'Bob'}>
  .flatMap(getAddress)                      // user.addressId is undefined -> Maybe<null> via getAddress
  .map(address => address.city)             // Stays Maybe<null>
  .getOrElse('City not found');
console.log("Bob's City:", bobsCity);   // City not found

const nonExistentUserCity = findUser('user3') // Maybe<null>
  .flatMap(getAddress)                      // Stays Maybe<null>
  .map(address => address.city)             // Stays Maybe<null>
  .getOrElse('City not found');
console.log("Non-existent User's City:", nonExistentUserCity); // City not found
```

---

## 🔍 Array-like Objects

**Definition:** Objects that have a `length` property and indexed elements (e.g., `0`, `1`, `2`), but are not actual arrays. They often lack array methods like `map`, `forEach`, etc.

### 1. Working with NodeLists
**Definition:** `NodeList` objects are collections of nodes, such as those returned by `document.querySelectorAll()`. They are array-like.  

```javascript
// This code should be run in a browser environment where 'document' is available.
// For this Markdown, we'll simulate.

// Simulate NodeList (in a non-browser environment)
const simulateNodeList = () => {
    const obj = {
        0: { tagName: 'DIV', textContent: 'First Div' },
        1: { tagName: 'P', textContent: 'Paragraph' },
        2: { tagName: 'DIV', textContent: 'Second Div' },
        length: 3,
        item: function(index) { return this[index]; }, // NodeList has an item() method
        // NodeList is also iterable in modern browsers
        [Symbol.iterator]: function* () {
            for (let i = 0; i < this.length; i++) {
                yield this[i];
            }
        }
    };
    return obj;
};
const divsNodeList = simulateNodeList(); // In browser: const divs = document.querySelectorAll('div');

// Traditional conversion approach (ES5 and earlier)
const divsArray1 = Array.prototype.slice.call(divsNodeList);
console.log("divsArray1 (from slice.call):", divsArray1.map(el => el.textContent));

// Modern approaches (ES6+)
const divsArray2 = Array.from(divsNodeList);
console.log("divsArray2 (from Array.from):", divsArray2.map(el => el.textContent));

const divsArray3 = [...divsNodeList]; // Spread operator works if NodeList is iterable
console.log("divsArray3 (from spread):", divsArray3.map(el => el.textContent));

// Direct manipulation after conversion or if methods are available
// Modern NodeLists often have forEach, but not map, filter, etc.
// Array.from(divsNodeList).forEach((div, index) => {
//   div.textContent = `Node ${index} (modified)`;
// });

// With transformation using Array.from's second argument
const divTexts = Array.from(divsNodeList, div => div.textContent.toUpperCase());
console.log("Transformed divTexts:", divTexts); // ['FIRST DIV', 'PARAGRAPH', 'SECOND DIV']
```

### 2. Arguments Object
**Definition:** An array-like object accessible inside functions that contains the values of the arguments passed to that function. It's largely superseded by rest parameters (`...args`) in modern JavaScript.  

```javascript
// Traditional function using 'arguments'
function traditionalSum() {
  console.log("Is 'arguments' an array?", Array.isArray(arguments)); // false
  // Convert 'arguments' to a real array to use array methods
  const argsArray = Array.prototype.slice.call(arguments);
  // Or: const argsArray = Array.from(arguments);
  // Or: const argsArray = [...arguments]; (if iterable, which it is)
  
  return argsArray.reduce((sum, num) => sum + num, 0);
}
console.log("traditionalSum(1,2,3):", traditionalSum(1, 2, 3, 4)); // 10

// Modern approach with rest parameters (preferred)
const modernSum = (...args) => {
  console.log("Is 'args' (from rest) an array?", Array.isArray(args)); // true
  return args.reduce((sum, num) => sum + num, 0);
};
console.log("modernSum(1,2,3,4,5):", modernSum(1, 2, 3, 4, 5)); // 15

// Example: processing arguments in older code
function processArgsOldStyle() {
  // Cannot use arguments.map directly as it's not an array method on `arguments`
  // return arguments.map(arg => typeof arg); // This would throw an error

  const argsArray = Array.from(arguments);
  return argsArray.map(arg => `Type: ${typeof arg}, Value: ${String(arg)}`);
}
console.log("processArgsOldStyle(1, 'hello', true, []):", processArgsOldStyle(1, 'hello', true, []));
// [ 'Type: number, Value: 1', 
//   'Type: string, Value: hello', 
//   'Type: boolean, Value: true', 
//   'Type: object, Value: ' ] (empty array stringifies to empty)
```

### 3. Custom Array-like Objects
**Definition:** Creating objects that mimic array behavior with a `length` property and indexed elements.  

```javascript
// Custom array-like constructor
function CustomArrayLike(...items) {
  // Set up indexed properties
  items.forEach((item, index) => {
    this[index] = item;
  });
  // Set the length property
  this.length = items.length;
}

// It's good practice to add methods to the prototype for efficiency
CustomArrayLike.prototype.push = function(item) {
  this[this.length] = item; // Add item at the current end
  return ++this.length;     // Increment length and return new length
};

CustomArrayLike.prototype.pop = function() {
  if (this.length === 0) return undefined;
  this.length--; // Decrement length first
  const item = this[this.length]; // Get item at new end
  delete this[this.length];       // Remove property
  return item;
};

// To make it truly useful with modern JS (e.g., for...of, spread), make it iterable
CustomArrayLike.prototype[Symbol.iterator] = function* () {
  for (let i = 0; i < this.length; i++) {
    yield this[i];
  }
};

// Add a custom method
CustomArrayLike.prototype.first = function() {
    return this.length > 0 ? this[0] : undefined;
}

// Usage
const myCustomList = new CustomArrayLike('a', 'b', 'c');
console.log("CustomList length:", myCustomList.length); // 3
console.log("CustomList element 0:", myCustomList[0]);   // 'a'
console.log("CustomList first():", myCustomList.first()); // 'a'


myCustomList.push('d');
console.log("CustomList after push 'd':", [...myCustomList]); // ['a', 'b', 'c', 'd'] (spread works due to iterator)
console.log("CustomList length after push:", myCustomList.length); // 4

const poppedItem = myCustomList.pop();
console.log("Popped item:", poppedItem); // 'd'
console.log("CustomList after pop:", [...myCustomList]); // ['a', 'b', 'c']
console.log("CustomList length after pop:", myCustomList.length); // 3

// Convert to a real array
const realArrayFromCustom = Array.from(myCustomList);
console.log("Is realArrayFromCustom an Array?", Array.isArray(realArrayFromCustom)); // true
console.log("Real array contents:", realArrayFromCustom); // ['a', 'b', 'c']

// Check if it behaves like an array-like for Array.prototype methods
console.log("Slice called on custom list:", Array.prototype.slice.call(myCustomList, 1)); // ['b', 'c']
```

---

## 🔬 Advanced Search & Sort

### 1. Binary Search
**Definition:** An efficient algorithm for finding an item within a **sorted** array by repeatedly dividing the search interval in half. Time complexity: O(log N).  

```javascript
// Binary search implementation (returns index or -1 if not found)
const binarySearch = (sortedArray, target) => {
  let left = 0;
  let right = sortedArray.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const midValue = sortedArray[mid];
    
    if (midValue === target) {
      return mid; // Target found
    } else if (midValue < target) {
      left = mid + 1; // Search in the right half
    } else {
      right = mid - 1; // Search in the left half
    }
  }
  
  return -1; // Target not found
};

// Binary search for insertion point (returns index where target should be inserted to maintain order)
const binarySearchInsertPoint = (sortedArray, target) => {
  let left = 0;
  let right = sortedArray.length; // Note: length, not length - 1
  
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    if (sortedArray[mid] < target) {
      left = mid + 1;
    } else {
      right = mid; // Potential insertion point, or element equal to target
    }
  }
  // `left` is the insertion point
  return left;
};

// Usage
const sortedNumbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
console.log("BinarySearch for 7:", binarySearch(sortedNumbers, 7));        // 3
console.log("BinarySearch for 8 (not found):", binarySearch(sortedNumbers, 8));        // -1
console.log("BinarySearch for 1:", binarySearch(sortedNumbers, 1));          // 0
console.log("BinarySearch for 19:", binarySearch(sortedNumbers, 19));        // 9

console.log("--- Insertion Points ---");
console.log("InsertPoint for 8:", binarySearchInsertPoint(sortedNumbers, 8));  // 4 (insert 8 at index 4: [...,7, *8*, 9,...])
console.log("InsertPoint for 0:", binarySearchInsertPoint(sortedNumbers, 0));  // 0 (insert 0 at index 0)
console.log("InsertPoint for 20:", binarySearchInsertPoint(sortedNumbers, 20)); // 10 (insert 20 at index 10, end of array)
console.log("InsertPoint for 7 (existing):", binarySearchInsertPoint(sortedNumbers, 7)); // 3 (index of existing 7)


// To insert using the point:
// const arrToInsert = [...sortedNumbers];
// const valToInsert = 8;
// const idx = binarySearchInsertPoint(arrToInsert, valToInsert);
// arrToInsert.splice(idx, 0, valToInsert);
// console.log(arrToInsert); // [1, 3, 5, 7, 8, 9, 11, 13, 15, 17, 19]
```

### 2. Advanced Sorting
**Definition:** Complex sorting scenarios, custom sort logic, and understanding sort stability.  

```javascript
// Multi-field sorting
// `sortKeys` can be:
// - string: property name (ascending)
// - function: (item) => value to sort by (ascending)
// - object: { field: 'propertyName' | function, desc?: boolean }
const multiPropertySort = (array, ...sortCriteria) => {
  return [...array].sort((a, b) => { // Use spread to sort a copy
    for (const criterion of sortCriteria) {
      let aVal, bVal, order = 1; // order 1 for ascending, -1 for descending

      if (typeof criterion === 'string') {
        aVal = a[criterion];
        bVal = b[criterion];
      } else if (typeof criterion === 'function') {
        aVal = criterion(a);
        bVal = criterion(b);
      } else if (typeof criterion === 'object') {
        if (typeof criterion.field === 'function') {
            aVal = criterion.field(a);
            bVal = criterion.field(b);
        } else {
            aVal = a[criterion.field];
            bVal = b[criterion.field];
        }
        if (criterion.desc) {
          order = -1;
        }
      } else {
        throw new Error('Invalid sort criterion');
      }
      
      if (aVal < bVal) return -1 * order;
      if (aVal > bVal) return 1 * order;
    }
    return 0; // Equal according to all criteria
  });
};

// Usage of multi-field sorting
const usersToSort = [
  { name: 'Alice', age: 30, score: 85, city: 'New York' },
  { name: 'Bob', age: 25, score: 90, city: 'London' },
  { name: 'Charlie', age: 30, score: 80, city: 'Paris' },
  { name: 'David', age: 25, score: 90, city: 'Berlin' },
  { name: 'Eve', age: 30, score: 85, city: 'Austin' },
];

const sortedUsers = multiPropertySort(
  usersToSort,
  { field: 'score', desc: true }, // Primary: Sort by score descending
  { field: 'age', desc: false },  // Secondary: Then by age ascending
  'name'                          // Tertiary: Then by name ascending
);
console.log("Sorted Users (multi-field):");
sortedUsers.forEach(u => console.log(`  ${u.name}, Score: ${u.score}, Age: ${u.age}`));
/* Expected rough order:
  David, Score: 90, Age: 25 (David before Bob due to name)
  Bob, Score: 90, Age: 25
  Alice, Score: 85, Age: 30 (Alice before Eve due to name)
  Eve, Score: 85, Age: 30
  Charlie, Score: 80, Age: 30
*/

// Stable sort implementation (Array.prototype.sort is stable since ES2019)
// This custom one demonstrates the concept if needed for older environments or specific logic.
const stableSort = (array, compareFn) => {
  return array
    .map((item, index) => ({ item, originalIndex: index })) // Pair with original index
    .sort((a, b) => {
      const comparisonResult = compareFn(a.item, b.item);
      // If items are considered equal by compareFn, use original index to maintain stability
      return comparisonResult !== 0 ? comparisonResult : a.originalIndex - b.originalIndex;
    })
    .map(({ item }) => item); // Unwrap items
};

const itemsWithDuplicates = [
  { name: 'itemA', value: 10, id: 1 },
  { name: 'itemB', value: 20, id: 2 },
  { name: 'itemC', value: 10, id: 3 }, // Same value as itemA
  { name: 'itemD', value: 5, id: 4 },
  { name: 'itemE', value: 10, id: 5 }, // Same value as itemA & itemC
];
// Sort by value, maintaining original order for equal values
const stablySortedItems = stableSort(itemsWithDuplicates, (a, b) => a.value - b.value);
console.log("Stably Sorted Items (by value):");
stablySortedItems.forEach(it => console.log(`  ${it.name} (val: ${it.value}, id: ${it.id})`));
// Expected: itemD (5), itemA (10, id:1), itemC (10, id:3), itemE (10, id:5), itemB (20)
// The order of itemA, itemC, itemE should be preserved relative to each other.

// Quick Sort (recursive, illustrative, not always most performant in JS due to recursion depth and engine opts)
const quickSort = (array) => {
  if (array.length <= 1) return array;
  
  const pivot = array[Math.floor(array.length / 2)];
  const less = [];
  const equal = [];
  const greater = [];
  
  for (const element of array) {
    if (element < pivot) {
      less.push(element);
    } else if (element > pivot) {
      greater.push(element);
    } else {
      equal.push(element);
    }
  }
  
  return [...quickSort(less), ...equal, ...quickSort(greater)];
};
const unsortedNumbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 0, -2];
console.log("QuickSort result:", quickSort(unsortedNumbers)); 
// [-2, 0, 1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
// Note: This simple quickSort is not stable.
```

---

## 🧱 Nested Arrays & Multidimensional

### 1. Definition & Access
**Definition:** Arrays that contain other arrays as elements, creating structures with multiple dimensions (e.g., matrices, tensors).  
**Accessing:** Use multiple bracket notations, e.g., `matrix[row][column]`, `tensor[depth][row][column]`.

```javascript
// 2D Array (Matrix)
const matrix = [
  [1, 2, 3],  // Row 0
  [4, 5, 6],  // Row 1
  [7, 8, 9]   // Row 2
];

console.log("Matrix element [0][0]:", matrix[0][0]); // 1 (first row, first column)
console.log("Matrix element [1][2]:", matrix[1][2]); // 6 (second row, third column)
console.log("Entire row 1:", matrix[1]); // [4, 5, 6]

// 3D Array (Tensor/Cube)
const cube = [
  [ // Layer 0
    [1, 2],  // Layer 0, Row 0
    [3, 4]   // Layer 0, Row 1
  ],
  [ // Layer 1
    [5, 6],  // Layer 1, Row 0
    [7, 8]   // Layer 1, Row 1
  ]
];
console.log("Cube element [0][1][0]:", cube[0][1][0]); // 3 (Layer 0, Row 1, Column 0)
console.log("Cube Layer 1, Row 0:", cube[1][0]); // [5, 6]
```

### 2. Iterating Nested Arrays
**Definition:** Traversing elements within nested structures, often requiring nested loops or recursive approaches.

```javascript
const complexMatrix = [
  [10, 20],
  [30, 40, 50], // Jagged array (rows have different lengths)
  [60]
];

// Using nested for loops (handles jagged arrays correctly)
console.log("Iterating with nested for loops:");
for (let i = 0; i < complexMatrix.length; i++) { // Iterate over rows
  for (let j = 0; j < complexMatrix[i].length; j++) { // Iterate over columns in current row
    console.log(`  Element [${i}][${j}]: ${complexMatrix[i][j]}`);
  }
}

// Using nested forEach
console.log("Iterating with nested forEach:");
complexMatrix.forEach((row, rowIndex) => {
  row.forEach((element, colIndex) => {
    console.log(`  Element [${rowIndex}][${colIndex}]: ${element}`);
  });
});

// Using map to transform a (non-jagged for simplicity here) matrix
const matrixToTransform = [[1,2],[3,4]];
const doubledMatrix = matrixToTransform.map(row => 
  row.map(element => element * 2)
);
console.log("Doubled Matrix:", doubledMatrix); // [[2, 4], [6, 8]]
```

### 3. Flattening Nested Arrays
**Definition:** Converting a nested array into a single-dimensional (flat) array.

```javascript
const deeplyNestedArray = [1, [2, 3, [4, [5, 600]]], 7, [8]];

// Using Array.prototype.flat() (ES2019)
console.log("Flat (depth 1):", deeplyNestedArray.flat());       
// [1, 2, 3, [4, [5, 600]], 7, 8]

console.log("Flat (depth 2):", deeplyNestedArray.flat(2));      
// [1, 2, 3, 4, [5, 600], 7, 8]

console.log("Flat (Infinity - fully flat):", deeplyNestedArray.flat(Infinity)); 
// [1, 2, 3, 4, 5, 600, 7, 8]

// Using Array.prototype.flatMap() (ES2019)
// flatMap is equivalent to map() followed by flat(1).
const wordsArray = ["hello world", "how are you"];
const allChars = wordsArray.flatMap(sentence => sentence.split(''));
console.log("flatMap example (allChars):", allChars);
// ['h','e','l','l','o',' ','w','o','r','l','d', 'h','o','w',' ','a','r','e',' ','y','o','u']

// Custom recursive flatten function (for environments without flat() or for learning)
const flattenDeepRecursive = (arr) => {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flattenDeepRecursive(val)) : acc.concat(val), 
  []);
};
console.log("Custom flattenDeepRecursive:", flattenDeepRecursive(deeplyNestedArray)); 
// [1, 2, 3, 4, 5, 600, 7, 8]

// Iterative flatten (can be more performant for very deep structures by avoiding recursion limits)
function flattenIterative(arr) {
    const result = [];
    const stack = [...arr]; // Initialize stack with array elements (reversed for order)
    while (stack.length) {
        const next = stack.pop(); // Get the last element
        if (Array.isArray(next)) {
            stack.push(...next); // If it's an array, push its elements onto the stack
        } else {
            result.unshift(next); // If it's not an array, add to the beginning of result
        }
    }
    return result;
}
// Or a version that preserves order more naturally:
function flattenIterativePreserveOrder(arr) {
    const result = [];
    const stack = [...arr.reverse()]; // Initialize stack with reversed array elements
    while (stack.length) {
        const next = stack.pop(); 
        if (Array.isArray(next)) {
            stack.push(...next.reverse()); // Push reversed elements to maintain order
        } else {
            result.push(next); 
        }
    }
    return result;
}
console.log("Custom flattenIterativePreserveOrder:", flattenIterativePreserveOrder(deeplyNestedArray));
// [1, 2, 3, 4, 5, 600, 7, 8]
```

### 4. Operations on Multidimensional Arrays
**Definition:** Performing calculations or transformations specific to multidimensional structures like matrices.

```javascript
// Matrix Transposition (swap rows and columns)
// Assumes a non-jagged matrix for simplicity
const transposeMatrix = matrix => {
  if (!matrix || matrix.length === 0 || !matrix[0] || matrix[0].length === 0) {
    return [];
  }
  const rows = matrix.length;
  const cols = matrix[0].length;
  
  const transposed = [];
  for (let j = 0; j < cols; j++) { // Iterate original columns (new rows)
    transposed[j] = [];
    for (let i = 0; i < rows; i++) { // Iterate original rows (new columns)
      transposed[j][i] = matrix[i][j];
    }
  }
  return transposed;
  // Shorter with map: return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
};

const originalMatrixForOps = [
  [1, 2, 3],
  [4, 5, 6]
];
const transposedMatrixResult = transposeMatrix(originalMatrixForOps);
console.log("Transposed Matrix:", transposedMatrixResult); 
// [[1, 4], [2, 5], [3, 6]]

// Sum of all elements in a matrix
const sumAllMatrixElements = matrix => {
  let totalSum = 0;
  for (const row of matrix) {
    for (const element of row) {
      totalSum += element;
    }
  }
  return totalSum;
  // Functional: return matrix.flat(Infinity).reduce((sum, el) => sum + el, 0);
  // Or: matrix.reduce((sum, row) => sum + row.reduce((rowSum, el) => rowSum + el, 0), 0);
};
console.log("Sum of originalMatrixForOps:", sumAllMatrixElements(originalMatrixForOps)); // 21

// Check if an element exists in a matrix
const findElementInMatrix = (matrix, elementToFind) => {
  for (const row of matrix) {
    if (row.includes(elementToFind)) { // .includes works on inner arrays
      return true;
    }
  }
  return false;
  // Functional: return matrix.some(row => row.includes(elementToFind));
};
console.log("Find 5 in matrix:", findElementInMatrix(originalMatrixForOps, 5)); // true
console.log("Find 10 in matrix:", findElementInMatrix(originalMatrixForOps, 10)); // false

// Matrix multiplication (A[m*n] * B[n*p] = C[m*p])
function multiplyMatrices(matrixA, matrixB) {
    const rowsA = matrixA.length;
    const colsA = matrixA[0].length;
    const rowsB = matrixB.length;
    const colsB = matrixB[0].length;

    if (colsA !== rowsB) {
        throw new Error("Cannot multiply matrices: Columns of A must equal Rows of B.");
    }

    const resultMatrix = Array.from({ length: rowsA }, () => Array(colsB).fill(0));

    for (let i = 0; i < rowsA; i++) {       // Iterate rows of A
        for (let j = 0; j < colsB; j++) {   // Iterate columns of B
            for (let k = 0; k < colsA; k++) { // Iterate common dimension (colsA or rowsB)
                resultMatrix[i][j] += matrixA[i][k] * matrixB[k][j];
            }
        }
    }
    return resultMatrix;
}
const matA = [[1, 2], [3, 4]]; // 2x2
const matB = [[5, 6, 7], [8, 9, 10]]; // 2x3
const productMat = multiplyMatrices(matA, matB);
console.log("Matrix A * Matrix B:", productMat); // [[21, 24, 27], [47, 54, 61]] (2x3)
```

---

## ✨ Modern Array Methods

This section covers newer array methods introduced primarily in ES2019 (ES10) and later, enhancing array manipulation capabilities.

### 1. `Array.prototype.flat()` (ES2019)
**Definition:** Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.  
**Syntax:** `arr.flat([depth])` (default `depth` is 1)  
**Returns:** New flattened array.  
**Mutates:** ❌ No  

```javascript
const arrFlat1 = [1, 2, [3, 4]];
console.log("arrFlat1.flat():", arrFlat1.flat()); // [1, 2, 3, 4]

const arrFlat2 = [1, 2, [3, 4, [5, 6]]];
console.log("arrFlat2.flat():", arrFlat2.flat()); // [1, 2, 3, 4, [5, 6]] (depth 1)
console.log("arrFlat2.flat(2):", arrFlat2.flat(2)); // [1, 2, 3, 4, 5, 6] (depth 2)

const arrFlat3 = [1, [2, [3, [4, [5]]]]];
console.log("arrFlat3.flat(Infinity):", arrFlat3.flat(Infinity)); // [1, 2, 3, 4, 5] (fully flat)

// flat() also removes empty slots (holes) in sparse arrays
const sparseArrayFlat = [1, , 3, [4, , 6]]; // 1 empty slot in outer, 1 in inner
console.log("sparseArrayFlat.flat():", sparseArrayFlat.flat()); // [1, 3, 4, 6] (empty slots removed)
```

### 2. `Array.prototype.flatMap()` (ES2019)
**Definition:** First maps each element using a mapping function, then flattens the result into a new array. It is functionally equivalent to `arr.map(...).flat(1)`, but `flatMap()` can be more efficient as it does both operations in one pass.  
**Syntax:** `arr.flatMap(callbackFn(currentValue, index, array))`  
**Returns:** New array.  
**Mutates:** ❌ No  

```javascript
const arrForFlatMap = [1, 2, 3, 4];

// Equivalent to map().flat(1)
const mappedThenFlat = arrForFlatMap.map(x => [x, x * 2]).flat();
console.log("Mapped then Flat:", mappedThenFlat); // [1, 2, 2, 4, 3, 6, 4, 8]

// Using flatMap directly
const flatMappedResult = arrForFlatMap.flatMap(x => [x, x * 2]);
console.log("flatMap Result:", flatMappedResult); // [1, 2, 2, 4, 3, 6, 4, 8]

// Use case: splitting words in sentences and getting a flat list of words
const sentences = ["flatMap is useful", "it maps and flattens"];
const allWords = sentences.flatMap(sentence => sentence.split(' '));
console.log("All words from sentences:", allWords); 
// ["flatMap", "is", "useful", "it", "maps", "and", "flattens"]

// Filtering and mapping simultaneously (by returning an empty array for items to discard)
const numbersForFlatMapFilter = [1, 2, 3, 4, 5, 6];
// Get squares of even numbers only
const squaresOfEvens = numbersForFlatMapFilter.flatMap(n => 
  n % 2 === 0 ? [n * n] : [] // Return an array with the item, or an empty array to "filter" it out
);
console.log("Squares of Evens (flatMap):", squaresOfEvens); // [4, 16, 36]
```

### 3. `Array.prototype.at()` (ES2022)
**Definition:** Takes an integer value and returns the item at that index. Positive integers work like bracket notation. Negative integers count back from the last item in the array (`-1` is the last item).  
**Syntax:** `arr.at(index)`  
**Returns:** Element at the specified index, or `undefined` if the index is out of bounds.  
**Mutates:** ❌ No  

```javascript
const arrayForAt = ['a', 'b', 'c', 'd', 'e'];

console.log("arrayForAt.at(0):", arrayForAt.at(0));  // 'a'
console.log("arrayForAt.at(2):", arrayForAt.at(2));  // 'c'

console.log("arrayForAt.at(-1):", arrayForAt.at(-1)); // 'e' (last element)
console.log("arrayForAt.at(-2):", arrayForAt.at(-2)); // 'd' (second to last element)

console.log("arrayForAt.at(10):", arrayForAt.at(10)); // undefined (index out of bounds)
console.log("arrayForAt.at(-10):", arrayForAt.at(-10)); // undefined (index out of bounds)

// Compare with bracket notation for last element:
// console.log(arrayForAt[arrayForAt.length - 1]); // 'e'
// .at(-1) is more concise and readable for this common case.
```

### 4. `findLast()` and `findLastIndex()` (ES2023)
**Definition:**
*   `findLast(callbackFn)`: Iterates the array in reverse order and returns the **value** of the first element that satisfies the provided testing function. If no elements satisfy the testing function, `undefined` is returned.
*   `findLastIndex(callbackFn)`: Iterates the array in reverse order and returns the **index** of the first element that satisfies the provided testing function. If no elements satisfy the testing function, `-1` is returned.  
**Syntax:** `arr.findLast(callbackFn(element, index, array))` / `arr.findLastIndex(callbackFn(element, index, array))`  
**Returns:** Value (for `findLast`) or Index (for `findLastIndex`). `undefined` / `-1` if not found.  
**Mutates:** ❌ No  

```javascript
const numbersForFindLast = [10, 20, 5, 30, 40, 25, 35, 15];

const lastNumGreaterThan30 = numbersForFindLast.findLast(n => n > 30);
console.log("Last number > 30:", lastNumGreaterThan30); // 35

const lastNumIndexGreaterThan30 = numbersForFindLast.findLastIndex(n => n > 30);
console.log("Index of last number > 30:", lastNumIndexGreaterThan30); // 6 (index of 35)

const lastNumLessThan10 = numbersForFindLast.findLast(n => n < 10);
console.log("Last number < 10:", lastNumLessThan10); // 5

const lastNumIndexLessThan10 = numbersForFindLast.findLastIndex(n => n < 10);
console.log("Index of last number < 10:", lastNumIndexLessThan10); // 2 (index of 5)


const usersWithRoles = [
  { id: 1, name: 'Alice', role: 'admin', active: true },
  { id: 2, name: 'Bob', role: 'user', active: false },
  { id: 3, name: 'Charlie', role: 'admin', active: false },
  { id: 4, name: 'Diana', role: 'editor', active: true },
  { id: 5, name: 'Eve', role: 'admin', active: true }
];

const lastActiveAdmin = usersWithRoles.findLast(user => user.role === 'admin' && user.active);
console.log("Last active admin:", lastActiveAdmin); // { id: 5, name: 'Eve', role: 'admin', active: true }

const lastAdminOverall = usersWithRoles.findLast(user => user.role === 'admin');
console.log("Last admin overall:", lastAdminOverall); // Same as above in this case

const noMatch = usersWithRoles.findLast(user => user.role === 'guest');
console.log("Find last guest:", noMatch); // undefined
```

### 5. Non-mutating Alternatives: `toSorted()`, `toReversed()`, `toSpliced()` (ES2023)
**Definition:** These methods provide non-mutating (immutable) versions of their historically mutating counterparts (`sort()`, `reverse()`, `splice()`). They always return a **new** array, leaving the original array unchanged.  
**Returns:** New array.  
**Mutates:** ❌ No  

```javascript
const originalArrayForNonMutating = [3, 1, 4, 0, 5, 9, 2, 6, 8, 7];
console.log("Original array:", originalArrayForNonMutating);

// toSorted() - non-mutating sort
const sortedCopy = originalArrayForNonMutating.toSorted((a, b) => a - b); // Ascending
console.log("Sorted copy (toSorted):", sortedCopy);     // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log("Original array (after toSorted):", originalArrayForNonMutating); // Unchanged

// toReversed() - non-mutating reverse
const reversedCopy = originalArrayForNonMutating.toReversed();
console.log("Reversed copy (toReversed):", reversedCopy);   // [7, 8, 6, 2, 9, 5, 0, 4, 1, 3]
console.log("Original array (after toReversed):", originalArrayForNonMutating); // Unchanged

// toSpliced() - non-mutating splice
// Syntax: array.toSpliced(start, deleteCount, ...itemsToInsert)
// Example: Remove 2 elements starting at index 2, and insert 'X', 'Y'
const splicedCopy = originalArrayForNonMutating.toSpliced(2, 3, 'X', 'Y', 'Z'); 
// Original: [3, 1, | 4, 0, 5, | 9, 2, 6, 8, 7]
// Deletes: 4, 0, 5
// Inserts: 'X', 'Y', 'Z'
console.log("Spliced copy (toSpliced):", splicedCopy);
// [3, 1, 'X', 'Y', 'Z', 9, 2, 6, 8, 7]
console.log("Original array (after toSpliced):", originalArrayForNonMutating); // Unchanged

// Example: Just inserting with toSpliced (deleteCount is 0)
const insertedOnlyCopy = originalArrayForNonMutating.toSpliced(1, 0, 99, 100);
console.log("Inserted only copy:", insertedOnlyCopy); // [3, 99, 100, 1, 4, 0, 5, 9, 2, 6, 8, 7]
```

### 6. `Array.prototype.with()` (ES2023)
**Definition:** Returns a **new** array with the element at the given `index` replaced with the given `value`. The original array is not modified.  
**Syntax:** `arr.with(index, value)`  
**Returns:** New array with the element at `index` replaced.  
**Mutates:** ❌ No  
**Error:** Throws a `RangeError` if `index` is out of bounds.

```javascript
const sourceArrayForWith = [10, 20, 30, 40, 50];
console.log("Source array (for with):", sourceArrayForWith);

const updatedArrayWith = sourceArrayForWith.with(2, 99); // Replace element at index 2 (value 30) with 99
console.log("Updated array (with):", updatedArrayWith);   // [10, 20, 99, 40, 50]
console.log("Source array (after with):", sourceArrayForWith);   // [10, 20, 30, 40, 50] (unchanged)

// Using negative index (counts from the end)
const updatedWithNegativeIndex = sourceArrayForWith.with(-1, 100); // Replace last element (value 50) with 100
console.log("Updated (negative index with):", updatedWithNegativeIndex); // [10, 20, 30, 40, 100]

// Trying to update out of bounds throws RangeError
try {
  const outOfBoundsUpdate = sourceArrayForWith.with(10, 0); // Index 10 is out of bounds
  console.log(outOfBoundsUpdate);
} catch (e) {
  console.error("Error with .with():", e.name, e.message); // RangeError: Invalid index : 10 (or similar message)
}
try {
  const outOfBoundsNegative = sourceArrayForWith.with(-10, 0); // Index -10 is out of bounds
  console.log(outOfBoundsNegative);
} catch (e) {
  console.error("Error with .with() negative:", e.name, e.message); 
}
```

---

## 🛠️ Array Optimization Techniques

Optimizing array operations can significantly impact application performance, especially with large datasets or in performance-critical sections of code.

### 1. Choosing the Right Iteration Method
*   **`for` loop (traditional `let i=0;...`):** Generally fastest for simple iteration due to minimal overhead. Allows `break` and `continue`.
*   **`for...of` loop:** Elegant for iterating values directly. Slightly more overhead than a `for` loop due to iterator protocol. Allows `break` and `continue`. Good for readability.
*   **`forEach()`:** Higher-order function. More concise for functional style. Has function call overhead per element. Not easily breakable (requires throwing an exception or other workarounds).
*   **`map()`, `filter()`, `reduce()` etc.:** Use when their specific semantic meaning is appropriate (transformation, filtering, aggregation). They create new arrays (except `reduce` which creates an accumulator), which has memory/performance implications. Chaining can be less performant than a single loop/reduce if intermediate arrays are large and not needed.

```javascript
const largeIterArray = Array.from({ length: 1_000_000 }, (_, i) => i);
let sum;

// For loop (illustrative - use the timeIt utility from Performance section for real tests)
console.time('for-loop-sum');
sum = 0;
for (let i = 0; i < largeIterArray.length; i++) {
  sum += largeIterArray[i];
}
console.timeEnd('for-loop-sum');
console.log("Sum (for):", sum);

// for...of loop
console.time('for-of-sum');
sum = 0;
for (const val of largeIterArray) {
  sum += val;
}
console.timeEnd('for-of-sum');
console.log("Sum (for...of):", sum);

// forEach
console.time('forEach-sum');
sum = 0;
largeIterArray.forEach(val => {
  sum += val;
});
console.timeEnd('forEach-sum');
console.log("Sum (forEach):", sum);

// reduce
console.time('reduce-sum');
sum = largeIterArray.reduce((acc, val) => acc + val, 0);
console.timeEnd('reduce-sum');
console.log("Sum (reduce):", sum);

// General guideline: Profile critical code. For most cases, readability of forEach/map/etc.
// is preferred unless performance is a proven bottleneck for that specific loop.
```

### 2. Pre-allocating Array Size
If you know the final size of an array, pre-allocating it *can* sometimes be more efficient as it *might* prevent multiple internal reallocations as the array grows dynamically with `push()`.  
**Syntax:** `const arr = new Array(size);` (creates a sparse array of `size` empty slots)  
Or initialize: `const arr = Array(size).fill(initialValue);` or `Array.from({length: size}, mapFn);`

```javascript
const knownSize = 100_000;

// Potentially less efficient if pushing one by one to an initially empty array
console.time('dynamic-push');
const arr1 = [];
for (let i = 0; i < knownSize; i++) {
  arr1.push(i); // Array might reallocate memory multiple times internally
}
console.timeEnd('dynamic-push');

// Pre-allocating and assigning by index
console.time('preallocate-assign');
const arr2 = new Array(knownSize); // Creates `knownSize` empty slots
for (let i = 0; i < knownSize; i++) {
  arr2[i] = i; // Assign directly to indices
}
console.timeEnd('preallocate-assign');

// Note: JavaScript engines are highly optimized. The benefit of manual pre-allocation
// might be minimal or even negative for smaller arrays or typical use cases due to the
// overhead of creating an array with many empty slots initially.
// `new Array(N)` creates a sparse array. For dense initialization, use:
// const arr3 = Array.from({ length: knownSize }, (_, i) => i);
// const arr4 = new Array(knownSize).fill(0).map((_, i) => i); // If map is needed after fill
```

### 3. Strategic Mutations vs. Immutability
*   **Immutability (creating new arrays):** Safer, easier to reason about state changes, essential for functional programming paradigms and state management libraries (e.g., React, Redux). Methods like `map`, `filter`, `slice`, spread (`...`), `toSorted()`, `toReversed()`, `toSpliced()`, `with()`. Can have performance overhead due to copying for very large arrays or frequent operations.
*   **Mutation (modifying in-place):** Can be more performant for very large arrays or in tight loops by avoiding memory allocation and copying. Methods like `push`, `pop`, `shift`, `unshift`, `splice`, `sort`, `reverse`, direct index assignment (`arr[i] = val`). Use with caution, especially if the array is shared or its previous state is important elsewhere.

```javascript
const dataToProcess = Array.from({length: 10000}, (_,i) => i);

// Immutable approach (creates a new array)
console.time('immutable-double');
const doubledImmutable = dataToProcess.map(x => x * 2);
console.timeEnd('immutable-double');

// Mutable approach (modifies the original array)
const dataToMutate = [...dataToProcess]; // Work on a copy for fair comparison here
console.time('mutable-double');
for (let i = 0; i < dataToMutate.length; i++) {
  dataToMutate[i] *= 2;
}
console.timeEnd('mutable-double');

// Consider the trade-off: performance vs. predictability and safety.
// The new ES2023 methods (toSorted, etc.) make immutability easier for operations
// that were traditionally mutable.
```

### 4. Understanding Method Complexity (Big O)
Be aware of the time complexity of array methods to choose wisely in performance-sensitive code:
*   Access (`arr[i]`): O(1)
*   `push()`, `pop()` (add/remove at end): O(1) on average (amortized)
*   `shift()`, `unshift()` (add/remove at start): O(N) because elements need to be re-indexed.
*   `slice()`, `concat()`: O(N) as they iterate and create new arrays (N is size of inputs).
*   `map()`, `filter()`, `forEach()`, `reduce()`: O(N) as they iterate over N elements.
*   `splice()`: O(N) in the worst case (e.g., splicing at the beginning).
*   `indexOf()`, `includes()`, `find()`, `findIndex()`: O(N) in the worst case (scan entire array).
*   `sort()`: O(N log N) on average (JS `sort` is typically Timsort or similar).
*   `flat()`: O(N*D) where N is total elements, D is depth, or O(N) if D=1. More complex for deep flattening.

For frequent lookups (`includes`, `find`) in large, static collections, consider converting the array to a `Set` or `Map` for O(1) average time complexity for `has()`/`get()`.

```javascript
const veryLargeList = Array.from({ length: 1_000_000 }, (_, i) => `item-${i}`);
const itemToFind = 'item-999999'; // Worst case for array search (last item)
const itemNotInList = 'item-nonexistent';

console.time('array.includes (found last)');
veryLargeList.includes(itemToFind);
console.timeEnd('array.includes (found last)');

console.time('array.includes (not found)');
veryLargeList.includes(itemNotInList);
console.timeEnd('array.includes (not found)');

const veryLargeSet = new Set(veryLargeList); // O(N) to build the set

console.time('set.has (found)');
veryLargeSet.has(itemToFind);
console.timeEnd('set.has (found)'); // Typically much faster for lookups

console.time('set.has (not found)');
veryLargeSet.has(itemNotInList);
console.timeEnd('set.has (not found)');
```

### 5. Impact of Sparse Arrays
Sparse arrays (arrays with "holes" or empty slots) can behave unexpectedly with some methods and might have performance implications.
*   `forEach()`, `map()`, `filter()` skip empty slots.
*   `for...in` loop includes indices of explicitly set `undefined` properties, but skips truly empty slots.
*   `Array.from()` or spread operator (`...`) convert empty slots to `undefined`.
*   `length` property reflects the highest index + 1, not actual number of elements.

```javascript
const sparseArr = [1, , 3]; // Slot at index 1 is empty
sparseArr[5] = 5;           // Now length is 6, slots 2, 3, 4 are empty

console.log("Sparse array:", sparseArr); // [1, empty, 3, empty, empty, 5]
console.log("Sparse array length:", sparseArr.length); // 6

console.log("forEach on sparse (skips empty):");
sparseArr.forEach((val, idx) => console.log(`  Index ${idx}: ${val}`)); // Logs for 1, 3, 5

const mappedSparse = sparseArr.map(val => val * 2);
console.log("Mapped sparse (empty slots remain empty):", mappedSparse); // [2, empty, 6, empty, empty, 10]

const denseFromSparse = Array.from(sparseArr);
console.log("Array.from(sparseArr) (empty slots become undefined):", denseFromSparse); 
// [1, undefined, 3, undefined, undefined, 5]

const spreadSparse = [...sparseArr];
console.log("[...sparseArr] (empty slots become undefined):", spreadSparse);
// [1, undefined, 3, undefined, undefined, 5]

// Generally, prefer dense arrays unless sparse arrays are intentionally used for specific
// memory optimization patterns (rare in typical JS client-side/Node.js code).
// Operations on sparse arrays can be slower as the engine may need to check for property existence.
```

### 6. Avoiding Unnecessary Work & Short-circuiting
*   **Short-circuiting:** Use methods like `some()`, `every()`, `find()`, `findIndex()` when you don't need to process the entire array once the condition is met/unmet. Traditional `for` loops with `break` or `return` also achieve this.
*   **Lazy evaluation:** For complex chains of operations on potentially very large arrays where you might only need a few results, consider libraries that support lazy evaluation (like Lodash's lazy sequences) or implement it yourself using generators (as shown in "Array Performance & Memory > Memory-Efficient Operations").

```javascript
const numbersToSearch = [1, 2, 3, -4, 5, 6, 100, 200, -50];

// Example: Check if any number is negative
console.time('some-for-negative');
const hasNegativeSome = numbersToSearch.some(n => {
    // console.log(`some checking: ${n}`); // For demo: stops after -4
    return n < 0;
});
console.timeEnd('some-for-negative');
console.log("Has negative (using some)?", hasNegativeSome); // true (efficient, stops at -4)

// Less efficient if filter is used just to check presence
console.time('filter-for-negative-check');
const negativesFound = numbersToSearch.filter(n => {
    // console.log(`filter checking: ${n}`); // For demo: checks all elements
    return n < 0;
});
const hasNegativeFilter = negativesFound.length > 0;
console.timeEnd('filter-for-negative-check');
console.log("Has negative (using filter)?", hasNegativeFilter); // true (less efficient, processes whole array)

// Example: Find the first number greater than 50
console.time('find-gt-50');
const firstGreaterThan50 = numbersToSearch.find(n => {
    // console.log(`find checking: ${n}`); // Stops at 100
    return n > 50;
});
console.timeEnd('find-gt-50');
console.log("First > 50 (using find):", firstGreaterThan50); // 100

// If you used filter().[0], it would process the whole array first.
// const firstGreaterThan50Filter = numbersToSearch.filter(n => n > 50)[0]; // Less efficient
```

---

## 🌍 Real-world Patterns

Arrays are fundamental in JavaScript, appearing in numerous real-world scenarios and common programming patterns.

### 1. Data Transformation Pipelines
Chaining array methods like `filter()`, `map()`, and `reduce()` to process and transform collections of data. This is extremely common when working with API responses, user inputs, or any dataset.

```javascript
const apiProductsResponse = [
  { id: "p1", name: "Laptop Pro", category: "Electronics", price: 1200.00, stock: 10, status: "active" },
  { id: "p2", name: "Wireless Mouse", category: "Electronics", price: 25.99, stock: 0, status: "active" },
  { id: "p3", name: "Mechanical Keyboard", category: "Electronics", price: 75.50, stock: 5, status: "archived" },
  { id: "p4", name: "JS Fundamentals Book", category: "Books", price: 29.99, stock: 20, status: "active" },
  { id: "p5", name: "Advanced JS Patterns", category: "Books", price: 49.50, stock: 0, status: "active" },
];

// Goal: Get names of all active, in-stock electronics, sorted by price (descending), formatted.
const processedProductNames = apiProductsResponse
  .filter(p => p.category === 'Electronics' && p.status === "active" && p.stock > 0)
  // At this point: [{ id: "p1", name: "Laptop Pro", ..., stock: 10 }]
  .sort((a, b) => b.price - a.price) // Sort by price descending
  // At this point (example): [{Laptop Pro}, ...]
  .map(p => `${p.name} - $${p.price.toFixed(2)}`)
  // At this point: ["Laptop Pro - $1200.00"]
  .join('; '); // Optional: join into a string

console.log("Processed Product Names:", processedProductNames); 
// "Laptop Pro - $1200.00" (only Laptop Pro matches all criteria)

// Goal: Calculate total value of all 'Books' currently in stock.
const totalBooksValueInStock = apiProductsResponse
  .filter(p => p.category === 'Books' && p.stock > 0)
  // [{ id: "p4", name: "JS Fundamentals Book", price: 29.99, stock: 20 }]
  .reduce((totalValue, book) => totalValue + (book.price * book.stock), 0);

console.log("Total Value of Books in Stock: $", totalBooksValueInStock.toFixed(2)); // (29.99 * 20) = 599.80
```

### 2. State Management (e.g., Redux-like Reducers)
Arrays are often used to manage lists of items in application state (e.g., a list of todos, users, posts). Reducers in state management patterns (like Redux, Vuex, or NgRx) update this state immutably.

```javascript
// Example: Todo list reducer (simplified)
const ActionTypes = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  REMOVE_TODO: 'REMOVE_TODO',
  EDIT_TODO_TEXT: 'EDIT_TODO_TEXT'
};

const initialTodosState = [
  { id: 1, text: 'Learn Advanced JavaScript Arrays', completed: true },
  { id: 2, text: 'Build a Cool App', completed: false }
];

let nextTodoId = 3; // Simple ID generation for this example

function todosReducer(state = initialTodosState, action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO:
      return [
        ...state, // Keep existing todos
        {         // Add the new todo
          id: nextTodoId++, 
          text: action.payload.text,
          completed: false
        }
      ];
    case ActionTypes.TOGGLE_TODO:
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, completed: !todo.completed } // Toggle completion for the matched todo
          : todo // Return other todos unchanged
      );
    case ActionTypes.REMOVE_TODO:
      return state.filter(todo => todo.id !== action.payload.id); // Keep todos that don't match ID
    
    case ActionTypes.EDIT_TODO_TEXT:
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, text: action.payload.newText }
          : todo
      );
    default:
      return state; // Return current state if action is not recognized
  }
}

// Simulate dispatches
let currentState = todosReducer(undefined, {}); // Initialize with default state
console.log("Initial Todo State:", currentState);

currentState = todosReducer(currentState, { type: ActionTypes.ADD_TODO, payload: { text: 'Master Reducers' } });
console.log("After ADD_TODO 'Master Reducers':", currentState);

currentState = todosReducer(currentState, { type: ActionTypes.TOGGLE_TODO, payload: { id: 2 } });
console.log("After TOGGLE_TODO (id:2):", currentState);

currentState = todosReducer(currentState, { type: ActionTypes.EDIT_TODO_TEXT, payload: { id: 1, newText: 'Review Advanced JS Arrays' } });
console.log("After EDIT_TODO_TEXT (id:1):", currentState);

currentState = todosReducer(currentState, { type: ActionTypes.REMOVE_TODO, payload: { id: 3 } });
console.log("After REMOVE_TODO (id:3):", currentState);
```

### 3. Implementing Stacks and Queues
Arrays can easily model LIFO (Last-In, First-Out) stacks and FIFO (First-In, First-Out) queues, although for performance-critical queues with many operations, specialized data structures (like linked lists or circular buffers) might be better because `array.shift()` is O(N).
*   **Stack:** Use `push()` to add to the top, `pop()` to remove from the top.
*   **Queue:** Use `push()` to enqueue (add to back), `shift()` to dequeue (remove from front).

```javascript
// Stack (LIFO)
const callStack = [];
callStack.push('main()');           // Stack: ['main()']
callStack.push('functionA()');      // Stack: ['main()', 'functionA()']
callStack.push('functionB()');      // Stack: ['main()', 'functionA()', 'functionB()']
console.log("Stack:", callStack);

console.log("Processing from stack:", callStack.pop()); // 'functionB()', Stack: ['main()', 'functionA()']
console.log("Processing from stack:", callStack.pop()); // 'functionA()', Stack: ['main()']
console.log("Processing from stack:", callStack.pop()); // 'main()', Stack: []
console.log("Stack empty:", callStack.length === 0); // true

// Queue (FIFO)
const messageQueue = [];
messageQueue.push({ task: 'Send email', priority: 1 });     // Queue: [task1]
messageQueue.push({ task: 'Process payment', priority: 0 });// Queue: [task1, task2]
messageQueue.push({ task: 'Update UI', priority: 2 });      // Queue: [task1, task2, task3]
console.log("Queue:", messageQueue.map(m => m.task));

console.log("Processing from queue:", messageQueue.shift().task); // 'Send email', Queue: [task2, task3]
console.log("Processing from queue:", messageQueue.shift().task); // 'Process payment', Queue: [task3]
console.log("Processing from queue:", messageQueue.shift().task); // 'Update UI', Queue: []
console.log("Queue empty:", messageQueue.length === 0); // true
```

### 4. UI Rendering (Lists of Components)
In UI frameworks like React, Vue, Angular, etc., arrays of data are commonly mapped to lists of UI elements or components. Each item in the array often corresponds to one rendered item, and a unique `key` is crucial for efficient updates.

```javascript
// Conceptual example (React-like JSX, this is not directly runnable JS without React)
/*
function UserListComponent({ users }) {
  if (!users || users.length === 0) {
    return <p>No users found.</p>;
  }
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          <strong>{user.name}</strong> ({user.status})
          <br />
          <em>{user.email}</em>
        </li>
      ))}
    </ul>
  );
}

const appUsersForUI = [
  { id: 'u1', name: 'Alice Wonderland', email: 'alice@example.com', status: 'active' },
  { id: 'u2', name: 'Bob The Builder', email: 'bob@example.com', status: 'inactive' },
  { id: 'u3', name: 'Charlie Chaplin', email: 'charlie@example.com', status: 'active' }
];

// In a React app, you would render: <UserListComponent users={appUsersForUI} />
// This would produce HTML like:
// <ul>
//   <li key="u1"><strong>Alice Wonderland</strong> (active)<br /><em>alice@example.com</em></li>
//   <li key="u2"><strong>Bob The Builder</strong> (inactive)<br /><em>bob@example.com</em></li>
//   <li key="u3"><strong>Charlie Chaplin</strong> (active)<br /><em>charlie@example.com</em></li>
// </ul>
*/

// Vanilla JS equivalent for demonstration of the data mapping part:
const appUsersForUIDemo = [
  { id: 'u1', name: 'Alice Wonderland', email: 'alice@example.com', status: 'active' },
  { id: 'u2', name: 'Bob The Builder', email: 'bob@example.com', status: 'inactive' },
];

function renderUserListVanilla(users, containerId) {
  const container = { innerHTML: '' }; // Simulate document.getElementById(containerId);
  
  if (!users || users.length === 0) {
    container.innerHTML = "<p>No users found.</p>";
    // In real DOM: container.appendChild(document.createElement('p').etc...);
    console.log(container.innerHTML);
    return;
  }

  const listItemsHtml = users.map(user => `
    <li data-id="${user.id}">
      <strong>${user.name}</strong> (${user.status})<br />
      <em>${user.email}</em>
    </li>
  `).join('');
  
  container.innerHTML = `<ul>${listItemsHtml}</ul>`;
  console.log("Rendered User List (Vanilla JS Mock):", container.innerHTML);
}

renderUserListVanilla(appUsersForUIDemo, 'user-list-container');
```

### 5. Batch Processing Asynchronous Operations
When you have an array of items that each require an asynchronous operation (e.g., fetching data from an API for each item), patterns like `Promise.all()` (for parallel execution) or sequential execution using `async/await` in a loop are common.

```javascript
const itemIdsToFetch = [101, 102, 103, 104, 105];

// Simulate an asynchronous API call
const fakeApiFetch = (id) => {
  return new Promise((resolve, reject) => {
    const delay = Math.random() * 1500 + 500; // 0.5s to 2s delay
    setTimeout(() => {
      if (id === 103) { // Simulate a failure for one item
        // console.log(`API call for ID ${id} FAILED after ${delay.toFixed(0)}ms`);
        reject(new Error(`Failed to fetch data for ID ${id}`));
      } else {
        // console.log(`API call for ID ${id} SUCCEEDED after ${delay.toFixed(0)}ms`);
        resolve({ id, data: `Data for item ${id}`, fetchedAt: new Date().toLocaleTimeString() });
      }
    }, delay);
  });
};

// Parallel processing with Promise.all (fails fast if one promise rejects)
async function fetchAllParallel_FailFast() {
  console.log("\n--- Fetching all in parallel (Promise.all - fail fast) ---");
  try {
    const fetchPromises = itemIdsToFetch.map(id => fakeApiFetch(id));
    const results = await Promise.all(fetchPromises); // Waits for ALL to complete or ONE to reject
    console.log("All parallel results (Promise.all):");
    results.forEach(r => console.log(`  Success: ID ${r.id}, Data: ${r.data}`));
    return results;
  } catch (error) {
    console.error("Error in parallel fetch (Promise.all):", error.message);
    // Only the first error is caught here.
  }
}
// fetchAllParallel_FailFast(); // Uncomment to run

// Parallel processing with Promise.allSettled (waits for all, captures all results/errors) (ES2020)
async function fetchAllParallel_Settled() {
  console.log("\n--- Fetching all in parallel (Promise.allSettled) ---");
  const fetchPromises = itemIdsToFetch.map(id => fakeApiFetch(id));
  const results = await Promise.allSettled(fetchPromises); // Waits for ALL to settle (fulfill or reject)
  
  console.log("All parallel results (Promise.allSettled):");
  results.forEach(result => {
    if (result.status === 'fulfilled') {
      console.log(`  Success: ID ${result.value.id}, Data: ${result.value.data}`);
    } else {
      console.error(`  Failed: ${result.reason.message}`);
    }
  });
  return results;
}
// fetchAllParallel_Settled(); // Uncomment to run

// Sequential processing (one after another)
async function fetchAllSequential() {
  console.log("\n--- Fetching all sequentially ---");
  const allResults = [];
  for (const id of itemIdsToFetch) {
    try {
      console.log(`Fetching ID ${id}...`);
      const result = await fakeApiFetch(id); // Waits for this one to complete
      console.log(`  Success for ID ${id}: ${result.data}`);
      allResults.push({ status: 'fulfilled', value: result });
    } catch (error) {
      console.error(`  Failed for ID ${id}: ${error.message}`);
      allResults.push({ status: 'rejected', reason: error });
      // Decide: continue with next, or break, or re-queue, etc.
    }
  }
  console.log("All sequential processing finished.");
  return allResults;
}
// fetchAllSequential(); // Uncomment to run
// To run these, uncomment the calls. They will log to console. Use with Node.js or browser.
```

### 6. Grouping Array Items
Often, you need to group items in an array based on a common property (e.g., group students by grade, group products by category). `Array.prototype.reduce()` is excellent for this. The newer `Object.groupBy()` (ES2024 proposal, check compatibility) provides a more direct way.

```javascript
const transactions = [
  { id: 't1', date: '2023-10-01', category: 'Groceries', amount: 50.25 },
  { id: 't2', date: '2023-10-01', category: 'Dining', amount: 30.00 },
  { id: 't3', date: '2023-10-02', category: 'Groceries', amount: 22.50 },
  { id: 't4', date: '2023-10-02', category: 'Transport', amount: 15.00 },
  { id: 't5', date: '2023-10-03', category: 'Dining', amount: 45.75 },
  { id: 't6', date: '2023-10-03', category: 'Groceries', amount: 10.00 },
];

// Group transactions by category using reduce()
const transactionsByCategory = transactions.reduce((acc, transaction) => {
  const key = transaction.category;
  if (!acc[key]) {
    acc[key] = []; // Initialize an array for this category if it doesn't exist
  }
  acc[key].push(transaction); // Add the current transaction to its category's array
  return acc; // Return the accumulator for the next iteration
}, {}); // Initial value for accumulator is an empty object

console.log("Transactions Grouped by Category (reduce):");
for (const category in transactionsByCategory) {
  console.log(`  ${category}: ${transactionsByCategory[category].length} transactions`);
  // transactionsByCategory[category].forEach(t => console.log(`    ID: ${t.id}, Amount: ${t.amount}`));
}
/* Output structure:
{
  Groceries: [ {id:'t1',...}, {id:'t3',...}, {id:'t6',...} ],
  Dining: [ {id:'t2',...}, {id:'t5',...} ],
  Transport: [ {id:'t4',...} ]
}
*/

// Group transactions by date using reduce()
const transactionsByDate = transactions.reduce((acc, transaction) => {
  const key = transaction.date;
  (acc[key] = acc[key] || []).push(transaction); // Shorter way to init and push
  return acc;
}, {});
console.log("\nTransactions Grouped by Date (reduce):");
// console.log(JSON.stringify(transactionsByDate, null, 2));


// Using Object.groupBy() (ES2024 - check browser/Node.js version for support)
// `Object.groupBy` is a static method on `Object`.
// It takes an iterable and a callback function that returns the key to group by.
if (Object.groupBy) {
    const transactionsByCategory_groupBy = Object.groupBy(transactions, tx => tx.category);
    console.log("\nTransactions Grouped by Category (Object.groupBy):");
    // console.log(JSON.stringify(transactionsByCategory_groupBy, null, 2));
     for (const category in transactionsByCategory_groupBy) {
        console.log(`  ${category}: ${transactionsByCategory_groupBy[category].length} transactions`);
    }

    // You can also group into a Map using Map.groupBy()
    const transactionsByDate_mapGroupBy = Map.groupBy(transactions, tx => tx.date);
    console.log("\nTransactions Grouped by Date (Map.groupBy):");
    transactionsByDate_mapGroupBy.forEach((txs, date) => {
        console.log(`  ${date}: ${txs.length} transactions`);
    });

} else {
    console.log("\nObject.groupBy or Map.groupBy not available in this environment.");
}
```

